<!DOCTYPE html>
<html>
<head>
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
    <script src="https://cdn.tailwindcss.com"></script>

    <script
            src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCFRCi9RiQ6jNMjspjXa6wVSVH7rbBnIGc&libraries=geometry,marker&callback=initMap&v=weekly"
            defer
    ></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <style>
        #map {
            height: 100%;
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        .delete-menu {
            position: relative;
            background: dodgerblue;
            padding: 5px;
            border: 2px solid orange;
            max-width: 50px;
            z-index: 1000;
            cursor: pointer;
        }
        /* General styles for the container */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        /* Styles for the input text box */
        /*input[type="text"], input[type="number"] {*/
        /*    width: 300px;*/
        /*    height: 40px;*/
        /*    padding: 10px;*/
        /*    margin: 10px 0;*/
        /*    margin-left: 20px;*/
        /*    font-size: 18px;*/
        /*    border: 1px solid #007bff;*/
        /*    border-radius: 8px;*/
        /*    box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);*/
        /*}*/
        select {
            width: 100px;
            height: 40px;
            padding-left: 10px;
            margin-top: 10px;
            margin-right: 20px;
            font-size: 18px;
            border: 1px solid #007bff;
            border-radius: 8px;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);
            background-color: #fff;
        }

        /* Styles for option elements */
        select option {
            padding: 10px;
            font-size: 18px;
        }

        /* Styles for the buttons */
        input[type="button"], input[type="submit"] {
            padding-left: 5px;
            padding-right: 5px;
            height: 40px;
            margin: 10px 5px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .button-primary {
            background-color: #007bff;
            color: white;
        }

        .button-primary:hover {
            background-color: #0056b3;
        }

        .button-secondary {
            background-color: #6c757d;
            color: white;
        }

        .button-secondary:hover {
            background-color: #5a6268;
        }
        .button-label {

            font-size: 16px; /* Slightly smaller font size for subtlety */
            color: #555; /* Softer color for text */
        }
        #instructions {
            display: none;
            margin: 20px 0;
            margin-left: 20px;
            padding: 10px;
            font-size: 18px;
            color: #333;
            border: 1px solid black;
            background-color: #f0f0f0; /* Light grey background */
            border-radius: 8px; /* Rounded edges */
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1); /* Optional: subtle shadow for better visual separation */
        }
        .popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            border: 1px solid black;
            box-shadow: 0px 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none; /* Hidden by default */
            padding: 10px;
            border-radius: 10px;
            width: 95%;
        }
        .slider-container {
            display: flex;
            flex-direction: column;
            margin-top: 10px;
            padding: 10px;
            align-items: center;
            background-color: #fafafa;
            border: 1px solid #ddd; /* Light border to distinguish the label */
            border-radius: 18px; /* Slightly rounded edges */
            box-shadow: none; /* Remove shadow for a flatter look */
            font-style: italic;
            opacity: 70%;
        }
        .vertical-container {
            display: flex;
            flex-direction: column;
            margin-right: 10px;
            gap: 5px;
            padding: 10px;
            align-items: center;
        }
        .horizontal-container {
            display: flex;
            flex-direction: row;
            margin-top: 10px;
            padding: 10px;
            gap: 10px;
            align-items: center;
        }

        .popup-content {
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            cursor: pointer;
            color: #333;
        }
        .floorSelector-button {
            width: 10px;
            height: 10px;
            background-color: white;
            border: 1px solid #ccc;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .popup h2 {
            margin-top: 0;
            font-size: 24px;
            font-weight: 400;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .popup label {
            font-size: 20px;
            display: block;
        }
        input[type="range"] {
            margin-top: 20px;
            min-width: 40px;
        }

        .popup input[type="text"], .popup input[type="number"], .popup input[type="file"] {
            width: calc(100% - 20px);
            padding: 10px;
            margin: 10px 0;
            font-size: 16px;
            border: 1px solid #007bff;
            border-radius: 5px;
        }

        .popup input[type="submit"], .popup button {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .popup input[type="submit"]:hover {
            background-color: #0056b3;
        }
        .button-container {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 10px;
        }
        .button-container button, .button-container input[type="submit"] {
            height: 40px;
        }
    </style>
    <script>
        let map;
        let mapOnCLickListener;
        let geocoder;
        let imageOverlay;
        let floorplanCoordinates;
        let allFloorplans = new Map();
        let polylines = [];
        let polylinesData;
        let overlays = new Map();
        let markerPairs = new Map(); //custom overlay resizing markers
        let advancedMarkers; //all poi markers
        let poiMarkers = [];//current floor poi markers
        let favColor = "#0cfabf";
        let currentPolyline;
        let selectedValueDropdown;
        let poiCoordinates;
        const toleranceRadius = 1; //snap to point radius
        let highlightedVertexIndex = null; //next line will be drawn from this vetrtex
        let currentFloorNum;
        let shortestRoute;
        let routePolyline;
        let graph;
        let floorDropdownOptions = [];
        let startNode = "0:53.381411419134636,-1.481581661349216";

        async function initMap() {
            await loadFloors();
            if (allFloorplans && allFloorplans.size > 0) {
                center = allFloorplans.get(0).center;
                map = new google.maps.Map(document.getElementById("map"), {
                    zoom: 20,
                    center: center,
                    disableDefaultUI: true,
                    heading: 0.0,
                    tilt: 0.0,
                    mapId: '9ef76c19e202c059',
                });
            } else {
                map = new google.maps.Map(document.getElementById("map"), {
                    zoom: 20,
                    center: { lat: 55.38169097419639, lng: -1.4820265913660122 },
                    disableDefaultUI: true,
                    heading: 0.0,
                    tilt: 0.0,
                    mapId: '9ef76c19e202c059',
                });
            }
            await loadMarkers();
            displayFloorPlan(0);

            await loadPolylines();
            createFloorSelectors();

            const inputDestination = document.createElement("input");
            inputDestination.type = "text";
            inputDestination.placeholder = "Enter a destination";
            inputDestination.id = "inputDestination";
            inputDestination.classList.add('w-11/12', 'text-center', 'p-5', 'rounded-xl', 'm-2.5', 'text-5xl', 'border-blue-500', 'border');

            const resultsContainer = document.createElement("div");
            resultsContainer.id = "resultsContainer";
            resultsContainer.classList.add('max-h-96', 'overflow-y-auto', 'text-3xl', 'w-11/12', 'text-center', 'bg-white', 'shadow-lg', 'rounded-xl', 'mt-2');

            const scanQRcodeBtn = document.createElement("button");
            scanQRcodeBtn.type = "button";
            scanQRcodeBtn.textContent = "Scan QR-code";
            scanQRcodeBtn.classList.add('w-fit', 'h-fit', 'rounded-xl', 'p-3.5', 'm-5', 'text-6xl', 'border-blue-500', 'border', 'bg-yellow-600', 'text-white');
            map.controls[google.maps.ControlPosition.BOTTOM_CENTER].push(scanQRcodeBtn);

            const verticalDiv = document.createElement("div");
            verticalDiv.classList.add('flex', 'flex-col', 'w-full', 'items-center');
            verticalDiv.appendChild(inputDestination);
            verticalDiv.appendChild(resultsContainer);
            map.controls[google.maps.ControlPosition.TOP_CENTER].push(verticalDiv);

            inputDestination.addEventListener("input", async (e) => {
                resultsContainer.style.display = "block";
                const query = e.target.value;
                if (query.length > 2) { // Only search when the query is at least 3 characters
                    const results = await searchPlaces(query);
                    displaySearchResults(results);
                } else {
                    resultsContainer.innerHTML = ''; // Clear results if query is too short
                }
            });
            async function searchPlaces(query) {
                //console.log(advancedMarkers);
                let results = [];
                for (const poi of advancedMarkers) {
                    const poiName = poi.name.toLowerCase();
                    const poiCategory = poi.category.toLowerCase();
                    if (poiName.includes(query.toLowerCase()) || poiCategory.includes(query.toLowerCase())
                        || query.toLowerCase().includes(poiName) || query.toLowerCase().includes(poiCategory)) {
                        results.push(poi);
                    }
                }
                return results;
            }
            function displaySearchResults(results) {
                resultsContainer.innerHTML = ''; // Clear previous results
                results.forEach(result => {
                    const resultItem = document.createElement("div");
                    resultItem.classList.add('text-4xl', 'text-gray-500','rounded-md', 'border', 'p-6', 'cursor-pointer', 'hover:bg-purple-500', 'hover:text-white');
                    resultItem.textContent = `${result.name} (Floor: ${result.floornum}, Type: ${result.category})`;
                    resultItem.addEventListener('click', () => {
                        map.setCenter(result.position);
                        currentFloorNum = result.floornum;
                        displayFloorPlan(result.floornum);
                        displayMarkers();
                        map.setZoom(21);
                        for (let option of floorDropdownOptions) {
                            if (option.value == result.floornum) {
                                option.selected = true;
                            }
                        }
                        resultsContainer.style.display = "none";
                    });
                    resultsContainer.appendChild(resultItem);
                });
            }
            mapOnCLickListener = map.addListener("click", (e) => {
                if (html5QrcodeScanner) {
                    html5QrcodeScanner.clear().then(() => {
                        console.log("QR Code scanning stopped.");
                    }).catch(err => {
                        console.error("Failed to stop scanning: ", err);
                    });
                }
                document.getElementById("popup").style.display = "none";
            });
            let html5QrcodeScanner
            scanQRcodeBtn.addEventListener("click", (e) => {
                html5QrcodeScanner = new Html5QrcodeScanner(
                    "reader",
                    { fps: 10, qrbox: {width: 300, height: 300} },
                    /* verbose= */ false);
                html5QrcodeScanner.render(onScanSuccess, onScanFailure);
                document.getElementById("popup").style.display = "block";


            });
            function onScanSuccess(decodedText, decodedResult) {
                // handle the scanned code as you like, for example:
                console.log(`Code matched = ${decodedText}`, decodedResult);
                let params = new URLSearchParams(decodedText);
                startNode = `${params.get('floornum')}:${params.get('lat')},${params.get('lng')}`;
                console.log(startNode);
                if (html5QrcodeScanner) {
                    html5QrcodeScanner.clear().then(() => {
                        console.log("QR Code scanning stopped.");
                    }).catch(err => {
                        console.error("Failed to stop scanning: ", err);
                    });
                }
                document.getElementById("popup").style.display = "none";
            }

            function onScanFailure(error) {
                // handle scan failure, usually better to ignore and keep scanning.
                // for example:
                console.warn(`Code scan error = ${error}`);
            }
            graph = buildGraph(polylinesData);
            await displayMarkers();
        }

        async function loadMarkers() {
            const response = await fetch('/api/markers');
            advancedMarkers = await response.json();
            //console.log(advancedMarkers);
            if (response.ok) {
                console.log('Markers loaded successfully');
            } else {
                alert('Failed to load markers');
            }
        }
        async function displayMarkers() {
            if (!advancedMarkers) {
                console.log(`Can't display poi markers: advancedMarkers = ${advancedMarkers}`);
                return;
            }
            const { AdvancedMarkerElement } = await google.maps.importLibrary("marker");
            for(let advMarker of poiMarkers) {
                removeMarker(advMarker);
            }
            poiMarkers = [];
            for (const marker of advancedMarkers) {
                if(marker.floornum === currentFloorNum) {
                    let pinColour;
                    let customMarkerContent = document.createElement('div');
                    customMarkerContent.style.width = '40px';
                    customMarkerContent.style.height = '40px';
                    // Set your desired background color
                    customMarkerContent.style.borderRadius = '50%';  // Make it a circle
                    customMarkerContent.style.display = 'flex';
                    customMarkerContent.style.justifyContent = 'center';
                    customMarkerContent.style.alignItems = 'center';
                    customMarkerContent.style.border = '2px solid black';
                    const emojiElement = document.createElement("div");
                    emojiElement.style.fontSize = "30px";
                    emojiElement.style.lineHeight = "1";
                    customMarkerContent.appendChild(emojiElement);
                    let isEmoji = true;
                    switch(marker.category) {
                        case "room":
                            pinColour = "#f5ed14";
                            isEmoji = false;
                            break;
                        case "lift":
                            pinColour = "#03fcf4";
                            emojiElement.innerText = "ðŸ›—";
                            break;
                        case "study area":
                            pinColour = "#627585";
                            emojiElement.innerText = "ðŸ“–";
                            break;
                        case "stairs":
                            pinColour = "#e803fc";
                            emojiElement.innerText = "ðŸªœ";
                            break;
                        case "entrance":
                            pinColour = "#FBBC04";
                            emojiElement.innerText = "ðŸšª";
                            break;
                        case "restrooms":
                            pinColour = "white";
                            emojiElement.innerText = "ðŸ’©";
                            break;
                        case "lecture theatre":
                            pinColour = "#710ced";
                            emojiElement.innerText = "ðŸ§‘â€ðŸ«";
                            break;
                        case "silent study":
                            pinColour = "#03fc17";
                            emojiElement.innerText = "ðŸ¤«";
                            break;
                        case "group study":
                            pinColour = "#c77a1c";
                            isEmoji = false;
                            break;
                        case "information":
                            pinColour = "#0791ed";
                            emojiElement.innerText = "i";
                            break;
                        case "food/drinks":
                            pinColour = "#2f8734";
                            emojiElement.innerText = "ðŸ”";
                            break;
                        case "default":
                            pinColour = "#000000";
                            isEmoji = false;
                            break;
                    }
                    customMarkerContent.style.backgroundColor = pinColour;
                    const pinBackground = new google.maps.marker.PinElement({
                        background: pinColour,
                        glyphColor: "white",
                        borderColor: "black"
                    });
                    if(!isEmoji) {
                        customMarkerContent = pinBackground.element;
                    }
                    const poiMarker = new AdvancedMarkerElement({
                        map,
                        position: marker.position,
                        title: `${marker.name} (Type: ${marker.category})`,
                        gmpClickable: true,
                        content: customMarkerContent
                    });
                    poiMarker.addListener("click", ({ domEvent, latLng }) => {
                        const { target } = domEvent;
                        const infoWindow = new google.maps.InfoWindow();
                        //infoWindow.close();
                        infoWindow.setContent(`
          <div>
            <div class="poiTitle"><strong>${poiMarker.title}</strong></div>
            <br>
            <button class="goHereBtn">Show directions</button>
          </div>
        `);
                        infoWindow.open(poiMarker.map, poiMarker);
                        google.maps.event.addListenerOnce(infoWindow, 'domready', () => {
                            document.querySelectorAll('.poiTitle').forEach(el => {
                                el.classList.add('text-4xl', 'text-purple-600');
                            });
                            document.querySelectorAll('.goHereBtn').forEach(btn => {
                                btn.classList.add('text-4xl','w-full', 'p-2', 'bg-yellow-500', 'border', 'rounded-md', 'text-white', 'm-2');
                                btn.addEventListener('click', () => {
                                    const endNode = `${marker.floornum}:${marker.position.lat},${marker.position.lng}`; // ending point
                                    shortestRoute = shortestPath(graph, startNode, endNode);
                                    console.log("Shortest Path:", shortestRoute);
                                    if (routePolyline) {
                                        removePolyline(routePolyline);
                                    }
                                    infoWindow.close();
                                    const [floorAndLat, lng] = startNode.split(',');  // Split into "floor:lat" and "lng"
                                    const [floor, lat] = startNode.split(':');
                                    map.setCenter({lat:Number(lat),lng:Number(lng)});
                                    currentFloorNum = Number(floor);
                                    displayFloorPlan(Number(floor));
                                    displayMarkers();
                                    map.setZoom(21);
                                    for (let option of floorDropdownOptions) {
                                        if (option.value == Number(floor)) {
                                            option.selected = true;
                                        }
                                    }
                                    if(shortestRoute) {
                                        drawShortestPath(shortestRoute);
                                    }
                                });
                            });
                        });
                    });
                    poiMarkers.push(poiMarker);
                }
            }
        }
        //Hide marker
        function removeMarker(poiMarker) {
            poiMarker.map = null;
            google.maps.event.clearInstanceListeners(poiMarker);
            //poiMarker = null;
        }

        function createFloorSelectors() {
            if(!allFloorplans) {
                return;
            }
            const floorDropdown = document.createElement('select');
            floorDropdown.classList.add('w-fit', 'text-center', 'h-fit', 'text-6xl', 'rounded-xl','p-2.5' , 'm-5', 'border-blue-500', 'border', 'bg-purple-600', 'text-white');
            allFloorplans.forEach(function(floor) {
                let option = document.createElement('option');
                floorDropdownOptions.push(option);
                option.textContent = floor.name;
                option.value = floor.order;
                if (floor.order == 0) {
                    option.selected = true;
                }
                floorDropdown.appendChild(option);
            });
            map.controls[google.maps.ControlPosition.BOTTOM_CENTER].push(floorDropdown);
            floorDropdown.addEventListener('change', function() {
                const selectedFloorOrder = Number(this.value);

                if (routePolyline) {
                    removePolyline(routePolyline);
                }
                displayFloorPlan(selectedFloorOrder);
                currentFloorNum = selectedFloorOrder;
                displayPolylines();
                displayMarkers();
                if(shortestRoute) {
                    drawShortestPath(shortestRoute);
                }
            });

        }
        async function loadFloors() {
            const response = await fetch('/api/floorPlans');
            const floorPlans = await response.json();
            floorPlans.sort((a, b) => a.order - b.order);
            floorPlans.forEach(floorPlan => {
                allFloorplans.set(floorPlan.order, floorPlan);
            });
        }

        function displayFloorPlan(floorNum) {
            if(allFloorplans.length < 1) {
                console.log("There are no floors");
                return;
            }
            let alreadyExists = false;
            if (overlays) {
                for(const overlay of overlays.values()) {
                    if (overlay.floorOrder === floorNum) {
                        alreadyExists = true;
                        imageOverlay = overlay;
                        overlay.setIsVisible(true);
                    } else {
                        overlay.setIsVisible(false);
                    }
                }
            }
            currentFloorNum = floorNum;
            class CustomImageOverlay extends google.maps.OverlayView {
                constructor(imageUrl, corners, map, rotation, floorNum) {
                    super();
                    this.imageUrl = imageUrl;
                    this.corners = corners; // An array of LatLng objects [northEast, northWest, southEast, southWest]
                    this.map = map;
                    this.div = null;
                    this.rotation = rotation || 0; // Rotation angle in degrees
                    this.setMap(map);
                    this.floorOrder = floorNum;
                    this.visible = true;
                }

                onAdd() {
                    this.div = document.createElement('div');
                    this.div.style.border = 'solid #007bff';
                    this.div.style.borderWidth = '2px';
                    this.div.style.position = 'absolute';

                    const img = document.createElement('img');
                    img.src = this.imageUrl;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.position = 'absolute';
                    img.style.transformOrigin = 'center';
                    img.style.opacity = '1';
                    this.img = img;
                    this.div.appendChild(img);

                    const panes = this.getPanes();
                    panes.overlayLayer.appendChild(this.div);
                }

                draw() {
                    if (!this.visible) {
                        this.div.style.display = 'none';
                        return;
                    }

                    this.div.style.display = 'block';
                    const overlayProjection = this.getProjection();

                    const ne = overlayProjection.fromLatLngToDivPixel(this.corners.northEast);
                    const sw = overlayProjection.fromLatLngToDivPixel(this.corners.southWest);

                    const div = this.div;
                    div.style.left = sw.x + 'px';
                    div.style.top = ne.y + 'px';
                    div.style.width = (ne.x - sw.x) + 'px';
                    div.style.height = (sw.y - ne.y) + 'px';

                    // Apply rotation transform
                    this.div.style.transform = `rotate(${this.rotation}deg)`;
                }

                onRemove() {
                    this.div.parentNode.removeChild(this.div);
                    this.div = null;
                }

                setRotation(angle) {
                    this.rotation = angle;
                    this.draw();
                }
                setIsVisible(val) {
                    this.visible = val;
                    this.draw();
                }
            }
            //############################
            if (!alreadyExists) {
                let corners;
                //console.log(allFloorplans.get(floorNum).corners);
                corners = allFloorplans.get(floorNum).corners;
                imageOverlay = new CustomImageOverlay(allFloorplans.get(floorNum).img, corners, map, allFloorplans.get(floorNum).rotation, floorNum);
                overlays.set(floorNum, imageOverlay);
            }
        }

        function attachVertexClickListener(polyline) {
            google.maps.event.addListener(polyline, "click", (e) => {
                if (e.vertex == undefined) {
                    return;
                }
                console.log(JSON.stringify(polyline.getPath().getAt(e.vertex)));
                // completeCurrentPolyline();
                // startNewPolyline();
                // addLatLng(e);
                // highlightVertex(e);
            });
        }

        function handleVertexDrag(path) {
            for (let i = 0; i < path.getLength(); i++) {
                const point = path.getAt(i);
                const snappedPoint = findNearbyPoint(point);
                if (snappedPoint && !point.equals(snappedPoint)) {
                    path.setAt(i, snappedPoint);
                }
            }
        }

        function attachDeleteMenuListener(polyline) {
            /**
             * A menu that lets a user delete a selected vertex of a path.
             */
            class DeleteMenu extends google.maps.OverlayView {
                div_;
                divListener_;
                constructor() {
                    super();
                    this.div_ = document.createElement("div");
                    this.div_.className = "delete-menu";
                    this.div_.innerHTML = "Delete";

                    const menu = this;

                    this.div_.addEventListener("click", (event) => {
                        event.stopPropagation();
                        menu.removeVertex();
                    });
                }
                onAdd() {
                    const deleteMenu = this;
                    const map = this.getMap();

                    this.getPanes().floatPane.appendChild(this.div_);
                    // mousedown anywhere on the map except on the menu div will close the
                    // menu.
                    this.divListener_ = map.getDiv().addEventListener(
                        "mousedown",
                        (e) => {
                            if (e.target != deleteMenu.div_) {
                                deleteMenu.close();
                            }
                        },
                        true,
                    );
                }
                onRemove() {
                    if (this.divListener_) {
                        google.maps.event.removeListener(this.divListener_);
                    }

                    this.div_.parentNode.removeChild(this.div_);
                    // clean up
                    this.set("position", null);
                    this.set("path", null);
                    this.set("vertex", null);
                }
                close() {
                    this.setMap(null);
                }
                draw() {
                    const position = this.get("position");
                    const projection = this.getProjection();

                    if (!position || !projection) {
                        return;
                    }

                    const point = projection.fromLatLngToDivPixel(position);

                    this.div_.style.top = point.y + "px";
                    this.div_.style.left = point.x + "px";
                }
                /**
                 * Opens the menu at a vertex of a given path.
                 */
                open(map, path, vertex) {
                    this.set("position", path.getAt(vertex));
                    this.set("path", path);
                    this.set("vertex", vertex);
                    this.setMap(map);
                    //this.draw();
                }
                /**
                 * Deletes the vertex from the path.
                 */
                removeVertex() {
                    const path = this.get("path");
                    const vertex = this.get("vertex");

                    if (!path || vertex == undefined) {
                        this.close();
                        return;
                    }

                    path.removeAt(vertex);
                    this.close();
                }
            }

            const deleteMenu = new DeleteMenu();
            google.maps.event.addListener(polyline, "contextmenu", (e) => {
                // Check if click was on a vertex control point
                if (e.vertex == undefined) {
                    return;
                }

                deleteMenu.open(map, polyline.getPath(), e.vertex);
            });
        }
        function findNearbyPoint(newPoint) {
            for (const polyline of polylines) {
                const path = polyline.getPath();
                for (let i = 0; i < path.getLength(); i++) {
                    const point = path.getAt(i);
                    if (google.maps.geometry.spherical.computeDistanceBetween(point, newPoint) <= toleranceRadius) {
                        return point;
                    }
                }
            }
            return null;
        }
        function highlightVertex(event) {
            const path = currentPolyline.getPath();
            for (let i = 0; i < path.getLength(); i++) {
                if (path.getAt(i).equals(event.latLng)) {
                    highlightedVertexIndex = i;
                    break;
                }
            }
            updateIcons(path);
        }

        function updateIcons(path) {
            if (highlightedVertexIndex !== null) {
                let icons = currentPolyline.get('icons');
                if (!icons || icons.length === 0) {
                    icons = [{
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 7,
                            fillColor: '#00FF00',
                            fillOpacity: 1,
                            strokeWeight: 2,
                            strokeColor: '#00FF00'
                        },
                        offset: '100%'
                    }];
                }
                currentPolyline.set('icons', icons);
            }
        }

        function displayPolylines() {
            // if (polylines) {
            //   for (const polyline of polylines) {
            //     removePolyline(polyline);
            //   }
            // }
            // polylines = [];
            // console.log("Polylines should be removed now");
            // for (const data of polylinesData) {
            //   if (data.floornum === currentFloorNum) {
            //     data.paths.forEach(p => {
            //       const polyline = new google.maps.Polyline({
            //         path: p.map(point => new google.maps.LatLng(point.lat, point.lng)),
            //         strokeColor: "#8442f5",
            //         strokeOpacity: 1.0,
            //         strokeWeight: 3,
            //         editable: true,
            //         draggable: true,
            //         map: map
            //       });
            //
            //       polylines.push(polyline);
            //
            //       const path = polyline.getPath();
            //       google.maps.event.addListener(path, 'set_at', () => handleVertexDrag(path));
            //       google.maps.event.addListener(path, 'insert_at', () => handleVertexDrag(path));
            //       attachDeleteMenuListener(polyline);
            //       attachVertexClickListener(polyline);
            //     });
            //   }
            // }
        }
        async function loadPolylines() {
            const response = await fetch('/api/polylines');
            polylinesData = await response.json();
        }
        function removePolyline(polyline) {
            polyline.setMap(null);
            google.maps.event.clearInstanceListeners(polyline);
            const path = polyline.getPath();
            if (path) {
                google.maps.event.clearInstanceListeners(path);
                path.forEach(function(latLng, index) {
                    google.maps.event.clearInstanceListeners(latLng);
                });
            }
            polyline = null;
        }
        function togglePopup() {
            const popup = document.getElementById("popup");
            popup.style.display = popup.style.display === "none" || popup.style.display === "" ? "block" : "none";
        }
        function buildGraph(polylinesData) {
            const graph = {};

            let printed = false;
            polylinesData.forEach((polyline) => {
                const floornum = polyline.floornum; // Get the floor number
                polyline.paths.forEach((path) => {
                    path.forEach((point, index) => {
                        const pointKey = `${floornum}:${point.lat},${point.lng}`; // Include floornum in the key
                        //console.log(pointKey);

                        // Initialize graph node if it doesn't exist
                        if (!graph[pointKey]) {
                            graph[pointKey] = [];
                        }

                        // Connect to the previous point
                        if (index > 0) {
                            const prevPoint = path[index - 1];
                            const prevPointKey = `${floornum}:${prevPoint.lat},${prevPoint.lng}`;
                            const distance = google.maps.geometry.spherical.computeDistanceBetween(
                                new google.maps.LatLng(prevPoint.lat, prevPoint.lng),
                                new google.maps.LatLng(point.lat, point.lng)
                            );

                            // Add bidirectional edges
                            graph[pointKey].push({ node: prevPointKey, weight: distance });
                            graph[prevPointKey].push({ node: pointKey, weight: distance });
                        }
                    });
                });
            });
            //link floors
            let stairsAndLifts = new Map();
            let distanceBetweenFloors = 3; //distance between the floors in meters
            for (const marker of advancedMarkers) {
                if (marker.category === "lift" || marker.category === "stairs") {
                    //console.log(`floor: ${marker.floornum} name: ${marker.name}`);
                    if (!stairsAndLifts.has(marker.name)) {
                        stairsAndLifts.set(marker.name, []);
                    }
                    stairsAndLifts.get(marker.name).push(marker);
                }
            }
            //console.log(stairsAndLifts);
            for (const pointsToBeConnected of stairsAndLifts.values()) {
                pointsToBeConnected.sort((a, b) => a.floornum - b.floornum);
                pointsToBeConnected.forEach((point, index) => {
                    const pointKey = `${point.floornum}:${point.position.lat},${point.position.lng}`;

                    // Connect to the previous point
                    if (index > 0) {
                        const prevPoint = pointsToBeConnected[index - 1];
                        const prevPointKey = `${prevPoint.floornum}:${prevPoint.position.lat},${prevPoint.position.lng}`;
                        const distance = distanceBetweenFloors;

                        // Add bidirectional edges
                        graph[pointKey].push({ node: prevPointKey, weight: distance });
                        graph[prevPointKey].push({ node: pointKey, weight: distance });
                    }
                });
            }
            return graph;
        }
        //Modified version of algorithm from https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/
        function dijkstra(graph, startNode) {
            const distances = {};
            const previous = {};
            const pq = new PriorityQueue((a, b) => distances[a] < distances[b]);

            // Initialize distances and priority queue
            for (let node in graph) {
                if (node === startNode) {
                    distances[node] = 0;
                    pq.enqueue(node);
                } else {
                    distances[node] = Infinity;
                }
                previous[node] = null;
            }

            while (!pq.isEmpty()) {
                const currentNode = pq.dequeue();

                graph[currentNode].forEach(neighbor => {
                    const distance = distances[currentNode] + neighbor.weight;

                    if (distance < distances[neighbor.node]) {
                        distances[neighbor.node] = distance;
                        previous[neighbor.node] = currentNode;
                        pq.enqueue(neighbor.node);
                    }
                });
            }

            return { distances, previous };
        }
        class PriorityQueue {
            constructor(comparator) {
                this._data = [];
                this._comparator = comparator;
            }

            enqueue(item) {
                this._data.push(item);
                this._data.sort(this._comparator);
            }

            dequeue() {
                return this._data.shift();
            }

            isEmpty() {
                return this._data.length === 0;
            }
        }
        function shortestPath(graph, startNode, endNode) {
            const { distances, previous } = dijkstra(graph, startNode);
            console.log(dijkstra(graph, startNode));
            let path = [];
            let currentNode = endNode;

            while (currentNode) {
                path.push(currentNode);
                currentNode = previous[currentNode];
            }

            return path.reverse();
        }
        function drawShortestPath(path) {
            if (path.length < 2) {
                console.log(`Couldn't find a path: ${path}`);
                return;
            }
            //helping user which floor to switch to along the route
            const relevantFloors = new Map();
            for (const floor of allFloorplans.keys()) {
                relevantFloors.set(Number(floor), 0);
            }
            let initialFloor;
            let isAscending
            const pathCoordinates = path.map(point => {
                const [floorAndLat, lng] = point.split(',');  // Split into "floor:lat" and "lng"
                const [floor, lat] = floorAndLat.split(':');  // Split "floor:lat" into "floor" and "lat"
                if (!initialFloor) {
                    initialFloor = floor;
                } else if (!isAscending) {
                    if (floor > initialFloor) {
                        isAscending = true;
                    } else if (floor < initialFloor) {
                        isAscending = false;
                    }
                }
                relevantFloors.set(Number(floor), Number(relevantFloors.get(Number(floor)))+1);
                if (Number(floor) !== currentFloorNum) {
                    return null;
                }
                return {floor:floor, lat: parseFloat(lat), lng: parseFloat(lng) };
            }).filter(point => point !== null);
            for (let [key, value] of relevantFloors) {
                if (value < 2) {
                    relevantFloors.delete(key);
                }
            }
            const relevantFloors2 = Array.from(relevantFloors.keys());
            relevantFloors2.sort((a, b) => a - b);
            console.log(pathCoordinates);
            let nextFloor;
            if (isAscending) {
                for (let i = 0; i < relevantFloors2.length - 1; i++){
                    if (relevantFloors2[i] === currentFloorNum) {
                        console.log(`Go to floor ${relevantFloors2[i+1]}`);
                        const lastCoordinate = pathCoordinates[pathCoordinates.length - 1];
                        const lastLat = lastCoordinate.lat;
                        const lastLng = lastCoordinate.lng;
                        const infoWindow = new google.maps.InfoWindow({
                            content: `<div class="text-5xl text-indigo-600">Go to floor ${relevantFloors2[i+1]}</div>`,
                        });
                        let marker = new google.maps.Marker({
                            position: {lat: lastLat, lng: lastLng},
                            map: map,
                            title: "You've reached the end!"
                        });
                        infoWindow.open(map, marker);
                        infoWindow.addListener('closeclick', () => {
                            // Remove the marker from the map when the infoWindow is closed
                            marker.setMap(null);
                            marker = null;
                        });
                        break;
                    }
                }
            } else {
                console.log("descending");
                for (let i = relevantFloors2.length; i > 0; i--) {
                    if (relevantFloors2[i] === currentFloorNum) {
                        console.log(`Go to floor ${relevantFloors2[i-1]}`);
                        const lastCoordinate = pathCoordinates[pathCoordinates.length - 1];
                        const lastLat = lastCoordinate.lat;
                        const lastLng = lastCoordinate.lng;
                        const infoWindow = new google.maps.InfoWindow({
                            content: `<div class="text-5xl text-indigo-600">Go to floor ${relevantFloors2[i-1]}</div>`
                        });
                        let marker = new google.maps.Marker({
                            position: {lat: lastLat, lng: lastLng},
                            map: map,
                            title: "You've reached the end!"
                        });
                        infoWindow.open(map, marker);
                        infoWindow.addListener('closeclick', () => {
                            // Remove the marker from the map when the infoWindow is closed
                            marker.setMap(null);
                            marker = null;
                        });
                        break;
                    }
                }
            }

            routePolyline = new google.maps.Polyline({
                path: pathCoordinates,
                geodesic: true,
                strokeColor: "#11bd3c",
                strokeOpacity: 1.0,
                strokeWeight: 5,
                map: map,
                icons: [{
                    icon: {
                        path: google.maps.SymbolPath.FORWARD_OPEN_ARROW,  // Arrow symbol
                        scale: 3,  // Size of the arrow
                        strokeColor: "#11bd3c",  // Color of the arrow
                    },
                    offset: '0%',  // Start from the beginning of the line
                    repeat: '130px'  // Repeat every 100 pixels
                }]
            });
        }

        window.initMap = initMap;
    </script>
</head>
<body>
<div id="popup" class="popup">
    <div class="popup-content">
        <div id="reader" width="600px"></div>
    </div>
</div>
<div id="map"></div>
<script>(g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await (a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})
    ({key: "AIzaSyCFRCi9RiQ6jNMjspjXa6wVSVH7rbBnIGc", v: "weekly"});</script>
</body>
</html>

